#!/usr/bin/env ruby -KU

ENV["PATH"] = "/usr/local/bin/:/opt/local/bin:#{ENV["PATH"]}"
ENV["RAILS_ENV"] ||= "production"

require File.dirname(__FILE__) + "/../config/environment"

abort("Usage: #{$0} repo_id") unless ARGV[0]

repo = Repository.find(ARGV[0])
project = repo.project
puts "Destroying existing events on #{project.slug}/#{repo.name}"
repo.events.destroy_all

tag_map = repo.git.tags.inject({}){|hsh, t| hsh[t.commit.id] = t.name;hsh}

parsed_commits = {} # Neccesary because of merge
repo.git.heads.each do |head|
  users_commits = {}
  
  Grit::Commit.find_all(repo.git, head.name, {:since => "1 year ago"}).each do |commit|
    users_commits[commit.committer.email] ||= []
    users_commits[commit.committer.email] << commit
  end
  
  users = User.find(:all, :conditions => ['email in (?)', users_commits.keys] )
  users.each do |user|
    commits = users_commits[user.email]
    
    commits.each_index do |i|
      commit = commits[i]
      previous_commit = commits[i-1]
      
      newrev = commit.id
      next if parsed_commits.has_key?(newrev)
      parsed_commits[newrev] = true
      
      oldrev = previous_commit.id if previous_commit
      current_rev = newrev
      newtype = oldtype = current_rev_type = "commit"
      
      type = repo.git.git.name_rev({}, newrev).last.split("/").first
      if type != "tags"
        type = "heads"
      end
      
      action = :create
      if !oldrev
        action = :create
      else
        if commit.id =~ /^0+$/
          action = :delete
        else
          action = :update
        end
      end

      if action != :delete
        newtype = repo.git.git.cat_file({:t => true}, newrev)
      end

      if action == :update
        oldtype = repo.git.git.cat_file({:t => true}, oldrev)
      end

      if action == :delete
          current_rev = oldrev
          current_rev_type = oldtype
      end
      

      
      action_id = nil
      ref = nil
      
      # if tagname = tag_map[commit.id]
      #   puts "@@@@@ TAGGED @@@@@@"
      #   if action == :create
      #     action_id = Action::CREATE_TAG
      #     ref = tagname
      #   elsif action == :delete
      #     action_id = Action::DELETE_TAG
      #     ref = tagname
      #   end
      # else
      #   case action
      #     when :create
      #       action_id = Action::CREATE_BRANCH
      #       ref = head.name
      #     when :update
      #       action_id = Action::COMMIT
      #       ref = current_rev
      #     when :delete
      #       action_id = Action::DELETE_BRANCH
      #       ref = head.name
      #   end
      # end
      
      if current_rev_type == "commit"
        if type == "heads"
          case action
            when :create
              action_id = Action::CREATE_BRANCH
              ref = head.name
            when :update
              action_id = Action::COMMIT
              ref = current_rev
            when :delete
              action_id = Action::DELETE_BRANCH
              ref = head.name
          end
        elsif type == "tags"
          if action == :create
            action_id = Action::CREATE_TAG
            ref = tag_map[commit.id]
          elsif action == :delete
            action_id = Action::DELETE_TAG
            ref = tag_map[commit.id]
          end
        end
      elsif current_rev_type == "tag"
        if type == "tags"
          if action == :create
            action_id = Action::CREATE_TAG
            ref = tag_map[commit.id]
          elsif action == :delete
            action_id = Action::DELETE_TAG
            ref = tag_map[commit.id]
          end
        end
      end
      
      
      # unless action_id
      #   puts "!_!_!_!_!_! no action reachable for #{commit.id}: #{commit.short_message}"
      #   next
      # end
      
      puts "#{current_rev_type}#{action.inspect} in #{head.name}: #{commit.short_message}"
      #project.create_event(action_id, repo, user, commit.id, commit.message)
      project.events.create({
        :action => action_id || Action::COMMIT, 
        :target => repo, 
        :user => user, 
        :body => commit.message, 
        :data => commit.id,
        :created_at => commit.committed_date})
    end
  end
end